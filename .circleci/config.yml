version: 2.1


parameters:
  poetry_version:
    type: string
    default: 1.4.2 # to co Marcin pisał, można zrobić update

  python_version:
    type: string
    default: 3.9.14

  # https://circleci.com/docs/using-macos/#supported-xcode-versions-silicon
  # https://circleci.com/docs/using-macos/#supported-xcode-versions-intel
  macos_xcode_version:
    type: string
    default: 14.2.0


executors:
  linux:
    docker:
      - image: python:<< pipeline.parameters.python_version >>
  # linux:
  #   machine:
  #     image: ubuntu-2204:2023.04.2
  mac: # m1 na płatnym?
    macos:
      xcode: << pipeline.parameters.macos_xcode_version >>


commands:
  install_python_and_gmp_mac:
    description: "A command to get specified python and poetry version on mac executor"
    steps:
      - restore_cache:
          keys:
            - mac-python-gmp-<< pipeline.parameters.python_version >>
      - run:
          name: Install python and gmp
          command: |
            pyenv install -s << pipeline.parameters.python_version >>
            pyenv global << pipeline.parameters.python_version >>
            HOMEBREW_NO_AUTO_UPDATE=1 brew install gmp
      - save_cache:
          key: mac-python-gmp-<< pipeline.parameters.python_version >>
          paths:
          - ~/.pyenv/versions/<< pipeline.parameters.python_version >>
          - /opt/homebrew/opt/gmp

  ensure_poetry_version:
    description: "Ensure poetry version"
    steps:
      - run:
          name: Install required poetry version
          command: |
            if ! poetry --version &> /dev/null || [[ $(poetry --version | awk '{print $NF}') != << pipeline.parameters.poetry_version >> ]]; then 
              echo "Poetry in wrong version, installing"
              pip3 install poetry==<< pipeline.parameters.poetry_version >>
            fi

  install_packages:
    parameters:
      platform:
        type: enum
        enum: ['linux', 'mac']
    steps:
      - run:
          name: Install packages
          command: |
            poetry config installer.modern-installation false
            if [[ << parameters.platform >> == "mac" ]]; then
              # https://github.com/python-poetry/poetry/issues/7184
              CFLAGS=-I/opt/homebrew/opt/gmp/include LDFLAGS=-L/opt/homebrew/opt/gmp/lib poetry --no-ansi install
            else
              poetry --no-ansi install
            fi

  checkout_with_submodules:
    steps:
      - checkout
      - run:
          name: Checkout code submodules
          command: |
            git submodule sync
            git submodule update --init

  install_rust:
    steps:
      - run:
          name: Install rust
          command: |
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            echo 'export PATH="$HOME/.cargo/bin:$PATH"' >> "$BASH_ENV"
            source "$BASH_ENV"

  setup:
    parameters:
      platform:
        default: linux
        type: enum
        enum: ['linux', 'mac']
    description: "A command to set up poetry, install deps and cairo bindings"
    steps:
      - when:
          condition:
            equal: ['mac', << parameters.platform >>]
          steps:
            - install_python_and_gmp_mac
      - ensure_poetry_version
      - checkout_with_submodules
      - restore_poetry_cache: # upewnij się że dziala, cos za maly zysk jest
          platform: << parameters.platform >>
      - install_packages:
          platform: << parameters.platform >>
      - save_poetry_cache:
          platform: << parameters.platform >>
      - install_rust
      - run:
          name: debug
          command: |
            ls $HOME/.cargo
            ls $HOME/.cargo/bin
            echo $PATH
            source "$HOME/.cargo/env"
            echo $PATH
            which rustup
      - run:
          name: Install cairo prod bindings
          command: poetry run poe install_cairo_bindings prod


  restore_poetry_cache:
    parameters:
      platform:
        type: enum
        enum: ['linux', 'mac']
    steps:
      - restore_cache: # dodatkowo jeszcze branch?
          key: poetry-<< pipeline.parameters.poetry_version >>-py<< pipeline.parameters.python_version >>-<< parameters.platform >>-{{ checksum "poetry.lock" }}

  save_poetry_cache: # czy cache powinno być również per branch?
    parameters:
      platform:
        type: enum
        enum: ['linux', 'mac']
    steps:
      - save_cache:
          key: poetry-<< pipeline.parameters.poetry_version >>-py<< pipeline.parameters.python_version >>-<< parameters.platform >>-{{ checksum "poetry.lock" }}
          paths:
            - ~/.cache/pypoetry

  lint:
    description: "Type checks, formatting and linting"
    steps:
      - run:
          name: Install cairo dev bindings
          command: |
            pip3 install patchelf
            poetry run ./scripts/install_cairo_bindings.sh # cachuj?
      - run:
          name: Run type check
          command: poetry run poe type_check
      - run: 
          name: Run Format check
          command: poetry run poe format_check
      - run:
          name: Run linter
          command: poetry run poe lint

  run_unit_tests:
    description: "Run unit tests"
    steps:
      - run:
          command: poetry run poe test_unit

  run_integration_tests:
    description: "Run integration tests"
    steps:
      - run:
          name: Ensure permissions to sierra-compile
          command: |
            PY_VER=$(echo << pipeline.parameters.python_version >> | awk 'BEGIN{FS=OFS="."} NF--')
            chmod +r $(poetry env info -p)/lib/python$PY_VER/site-packages/starkware/starknet/compiler/v1/bin/starknet-sierra-compile
      - run:
          command: pytest -n16 --random-order scripts tests/integration


  # e2e_tests:

jobs:

  code_quality:
    executor: linux
    steps:
      - setup
      - lint

  unit_tests:
    parameters:
      platform:
        type: enum
        enum: ['linux', 'mac']
    executor: << parameters.platform >>
    steps:
      - setup:
          platform: << parameters.platform >>
      - run:
          command: poetry run ./scripts/install_cairo_bindings.sh
      - run:
          command: git config --global protocol.file.allow always
      - run_unit_tests
      - run_integration_tests
      # - e2e_tests # rodzaje testów moga iść in parallel?



workflows:
  version: 2

  protostar:
    jobs:
      - code_quality
      - unit_tests:
          matrix:
            parameters:
              platform: [linux, mac]
      # - build_linux: # i verify jako ostatni step jobów buildowych
      #     requires:
      #       - checks
      # - build_mac: # i verify jako ostatni step jobów buildowych
      #     requires:
      #       - checks
      # - publish_approval:
      #     type: approval
      #     requires:
      #       - build_linux
      #       - build_mac
      # - publish:
      #     requires:
      #       - build_linux
      #       - build_mac
      #     filters:
      #       branches:
      #         only:
      #           - master

# test releases z branchów, tylko gdzie je wrzucać? circleci artifacts?